-- 1. 전지연 사원이 속해있는 부서원들을 조회하시오 (단, 전지연은 제외)
-- 사번, 사원명, 전화번호, 고용일, 부서명
SELECT
	EMP_ID,
	EMP_NAME,
	PHONE,
	HIRE_DATE,
	DEPT_TITLE
FROM EMPLOYEE "MAIN"
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
WHERE "MAIN".DEPT_CODE = (
		-- '전지연'이 속해있는 부서
		SELECT DEPT_CODE
		FROM EMPLOYEE "SUB"
		WHERE "SUB".EMP_NAME = '전지연'
)
AND "MAIN".EMP_NAME ^= '전지연';



-- 2. 고용일이 2010년도 이후인 사원들 중 급여가 가장 높은 사원의
-- 사번, 사원명, 전화번호, 급여, 직급명을 조회하시오.
WITH SALARY_RANK
AS (
	SELECT
				RANK() OVER (ORDER BY SALARY DESC) "랭크",
				EMP_ID,
				EMP_NAME,
				PHONE,
				SALARY,
				DEPT_CODE
			FROM EMPLOYEE
			WHERE HIRE_DATE >= TO_DATE('2010-01-01', 'YYYY-MM-DD')
)
SELECT
	EMP_ID,
	EMP_NAME,
	PHONE,
	SALARY,
	DEPT_TITLE
FROM SALARY_RANK
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
WHERE "랭크" = 1;

-- 3. 노옹철 사원과 같은 부서, 같은 직급인 사원을 조회하시오. (단, 노옹철 사원은 제외)
-- 사번, 이름, 부서코드, 직급코드, 부서명, 직급명
SELECT
	"MAIN".EMP_ID,
	"MAIN".EMP_NAME,
	"MAIN".DEPT_CODE,
	"MAIN".JOB_CODE,
	DEPT_TITLE,
	JOB_NAME
FROM EMPLOYEE "MAIN"
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
LEFT JOIN JOB ON("MAIN".JOB_CODE=JOB.JOB_CODE)
WHERE ("MAIN".DEPT_CODE, "MAIN".JOB_CODE) = (
		SELECT
			"SUB".DEPT_CODE,
			"SUB".JOB_CODE
		FROM EMPLOYEE "SUB"
		WHERE "SUB".EMP_NAME = '노옹철'
)
AND "MAIN".EMP_NAME != '노옹철';



-- 4. 2010년도에 입사한 사원과 부서와 직급이 같은 사원을 조회하시오
-- 사번, 이름, 부서코드, 직급코드, 고용일
SELECT
	EMP_ID,
	EMP_NAME,
	DEPT_CODE,
	JOB_CODE,
	TO_CHAR(HIRE_DATE, 'YY"년" MM"월" DD"일"')
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) = (
		SELECT DEPT_CODE, JOB_CODE
		FROM EMPLOYEE
		WHERE EXTRACT(YEAR FROM HIRE_DATE) = 2010
);


-- 5. 87년생 여자 사원과 동일한 부서이면서 동일한 사수를 가지고 있는 사원을 조회하시오
-- 사번, 이름, 부서코드, 사수번호, 주민번호, 고용일
SELECT
	EMP_ID,
	EMP_NAME,
	DEPT_CODE,
	MANAGER_ID,
	EMP_NO,
	TO_CHAR(HIRE_DATE, 'DD.MM.YYYY')
FROM EMPLOYEE
WHERE (DEPT_CODE, MANAGER_ID) = (
SELECT DEPT_CODE, MANAGER_ID
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 1, 2) = '87'
AND SUBSTR(EMP_NO, 8, 1) IN (2,4)
);


-- 6. 부서별 입사일이 가장 빠른 사원의
-- 사번, 이름, 부서명(NULL이면 '소속없음'), 직급명, 입사일을 조회하고
-- 입사일이 빠른 순으로 조회하시오
-- 단, 퇴사한 직원은 제외하고 조회..
SELECT
	*
FROM EMPLOYEE
ORDER BY DEPT_CODE ASC, HIRE_DATE ASC;

-- 1) 상관 서브쿼리를 이용한 방법 (정확도가 더 높음)

SELECT
	EMP_ID,
	EMP_NAME,
	NVL(DEPT_TITLE, '소속없음') "부서",
	JOB_NAME,
	HIRE_DATE
FROM EMPLOYEE "MAIN"
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
LEFT JOIN JOB USING(JOB_CODE)
WHERE "MAIN".HIRE_DATE =
		(SELECT MIN("SUB".HIRE_DATE)
		FROM EMPLOYEE "SUB"
		WHERE NVL("MAIN".DEPT_CODE, '소속없음') = NVL("SUB".DEPT_CODE, '소속없음')
		AND ENT_YN != 'Y')	-- 퇴사한 직원 빼고 최솟값 계산해야함
												-- 밖에서하면 안됨
ORDER BY "MAIN".HIRE_DATE ASC;

-- 2) GROUP BY 이용법 : 다른부서의 같은날 입사자가 선택될 수 있음

SELECT
	EMP_ID,
	EMP_NAME,
	DEPT_TITLE,
	JOB_NAME,
	HIRE_DATE
FROM EMPLOYEE E
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
LEFT JOIN JOB ON(E.JOB_CODE = JOB.JOB_CODE)
WHERE HIRE_DATE IN 
		(SELECT	MIN(HIRE_DATE)
		FROM EMPLOYEE F
		WHERE ENT_YN <> 'Y'
		GROUP BY DEPT_CODE)
ORDER BY HIRE_DATE ASC;

-- 7. 직급별 나이가 가장 어린 직원의
-- 사번, 이름, 직급명, 만 나이, 보너스 포함 연봉( (급여 * (1 + 보너스)) * 12)을 조회하고
-- 나이순으로 내림차순 정렬하세요
-- 단 연봉은 \124,800,000 으로 출력되게 하세요. (\ : 원 단위 기호
SELECT
	TO_CHAR(SALARY, 'l999,999,999'),
	JOB_CODE
FROM EMPLOYEE;


SELECT
	"MAIN".EMP_ID "사번",
	"MAIN".EMP_NAME "이름",
	JOB_NAME "직급",
	FLOOR( 
			MONTHS_BETWEEN(
					TO_DATE('2024-08-21 00:00', 'YYYY-MM-DD HH24:MI'),
					TO_DATE( SUBSTR("MAIN".EMP_NO, 1, 6) )) / 12 
	) "나이",
	TO_CHAR(("MAIN".SALARY * (1 + NVL("MAIN".BONUS, 0))) * 12, 'L999,999,999') AS "연봉"
FROM EMPLOYEE "MAIN"
LEFT JOIN JOB ON("MAIN".JOB_CODE = JOB.JOB_CODE)
WHERE SUBSTR("MAIN".EMP_NO, 1, 6) = (
		SELECT MAX(SUBSTR("SUB".EMP_NO, 1, 6))
		FROM EMPLOYEE "SUB"
		WHERE "MAIN".JOB_CODE = "SUB".JOB_CODE
)
ORDER BY 나이 DESC;


-- 1) 직급별 나이가 가장 어린 직원
SELECT MAX(TO_DATE(SUBSTR(EMP_NO, 1, 6)))
FROM EMPLOYEE
GROUP BY JOB_CODE;

-- 2) 다중행 서브쿼리를 이용해서 생일이 일치하는 사원들 조회
SELECT 
	EMP_ID "사번",
	EMP_NAME "이름",
	JOB_NAME "직급",
	FLOOR(MONTHS_BETWEEN(
	CURRENT_DATE, TO_DATE(SUBSTR(E.EMP_NO,1,6)))/12) "연세",
	(SALARY * (1 + NVL(BONUS, 0))) * 12 "연봉"
FROM EMPLOYEE E
JOIN JOB      J ON (E.JOB_CODE = J.JOB_CODE)
WHERE TO_DATE(SUBSTR(EMP_NO, 1, 6)) 
	IN (
		SELECT MAX( TO_DATE(SUBSTR(EMP_NO, 1, 6)) )	-- 다중행(7행)
		FROM EMPLOYEE
		GROUP BY JOB_CODE)
ORDER BY 연세 DESC;

/*상관서브쿼리를 이용하는 것이 정확도가 높다.*/
SELECT 
	EMP_ID,
	EMP_NAME,
	JOB_NAME,
	
	FLOOR(
		MONTHS_BETWEEN(
			CURRENT_DATE, 
			TO_DATE(SUBSTR(EMP_NO, 1, 6))) / 12 ) "만 나이",
		
	(SALARY * ( 1 + NVL(BONUS,0) )) * 12 "연봉"
FROM EMPLOYEE E
JOIN JOB      J ON (E.JOB_CODE = J.JOB_CODE)
WHERE TO_DATE(SUBSTR(EMP_NO, 1, 6)) 
	= (
		SELECT MAX( TO_DATE(SUBSTR(EMP_NO, 1, 6)) )
		FROM EMPLOYEE "SUB"
		WHERE "SUB".JOB_CODE = E.JOB_CODE)
		-- 현재 메인쿼리의 해석되는 행이 
		--  해당 직급에서 가장 어린 사원이 맞는지 비교
ORDER BY "만 나이" DESC;





















